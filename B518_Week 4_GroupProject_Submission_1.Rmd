---
title: "B518 | Week 4 | Group Project | Submission 1"
author: "Group 4 - Alex Toon | Nicholas Carlson | Divya Reddy Konda"
date: "`r Sys.Date()`"
output:
  pdf_document:
    number_sections: true
    latex_engine: xelatex
fontsize: 11pt
header-includes:
  - \usepackage{placeins}
params:
---

```{r include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.width = 6.5,
  fig.height = 3.6
)

suppressPackageStartupMessages({
  library(readr)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(knitr)
})

```

# Project Idea One - Covid 19 (2021 ONLY - USA, UK, China, Belgium)
## 1) Source: URL: https://docs.owid.io/projects/covid/en/latest/dataset.html

### Selection Criteria:
#### The data (see above) does meet the criteria of the assignment. In that it is relevant to health, publically accessible, sizable (61 columns and 530,292 rows), includes both categorical (e.g. country) and continuous variables (e.g. new_cases_per_million, total_deaths_per_million) and finally has been ethically sourced and de-identified. 



```{r dataset_one_import}
dataset_one_URL <- "https://docs.owid.io/projects/covid/en/latest/dataset.html"
dataset_one_URL # to print the URL for the PDF

data1 <- readr::read_csv("https://drive.google.com/uc?export=download&id=1D3Bka-78tuEbXn7XXxgYoSssHoy2DKpf", show_col_types = FALSE)

c(n_rows = nrow(data1), n_cols = ncol(data1))
head(names(data1), 12)

u <- unique(data1$country)
u[grepl("United|USA|UK", u, ignore.case = TRUE)]
```


## 2) Introduction (4-6 Sentences)
This project uses Covid 19 data from 'Our world in data'. We use this to primarily compare how daily new cases per million varied across four countries in 2021. We focus on 2021 to keep our comparisons on a common phase of the pandemic. The dataset itself does cover many more countries and years and also includes data on total cases and total deaths. We used the fields that have the suffix 'per_million'as any comparisons scale by population size. 

## 3) Why this dataset? (1 paragraph)
 This dataset is highly relevant to health outcomes. The dataset is also very well documented, large (61 columns and 530k rows). For analysis potential, this dataset has both continuous fields (total_deaths_per_million, new_cases_per_million)  and categorical (e.g. Country), feasible for tables, histograms, boxplots, time trends. Using the fields with the suffix "per_million" allows better scaling for cross country comparisons and summaries. 
  
## 4) Variables and structure
  
```{r Variables_and_structure}

#Size
c(n_rows = nrow(data1), n_cols = ncol(data1))

#Column Names
head(names(data1))

#Types
table(sapply(data1, function(x) class(x)[1]))

#quick analysis

str(data1, list.len = 20)
head(data1, 10)
summary(data1)

```
## 5) Research questions
- 1. What share of days exceed a threshold (to simulated a government policy threshold to "flatten the curve") e.g 50 cases per million in each country
- 2. Which of the selected countries had the highest typical daily new cases per million in 2021
- 3. How did the monthly mean of new cases per million over 2021 for each country

## 6) Data clean up & Processing plan
We parsed the date field and derived a 'year' variable, then restricted the dataset to 2021 to keep figures more legible and comparable. We fixed our analysis to a small set of countries (United States, United Kingdom, China, Belgium) and then verified each has sufficient non missing values for 'new_cases_per_million' in 2021. this processing prepares the data for descriptive statistics and many visualisations.    
```{r data_clean_up}

#check year is available & parse
data1$date <- as.Date(data1$date)
data1$year <- as.integer(format(data1$date, "%Y"))

#filter by one year to reduce dataset. Focusing on year 2021
d1_21 <- subset(data1, year ==2021)


# lock in selected countries
keep_countries <- c("United States", "United Kingdom", "China", "Belgium")


# Only keep countries with enough non missing values for 'new_cases_per_million'
ok_counts <- tapply(!is.na(d1_21$new_cases_per_million), d1_21$country, sum)

#show counts for chosen countries
counts_chosen <- ok_counts[keep_countries]
counts_chosen

d1_21_f <- subset(d1_21,
            country %in% keep_countries,
            select = c(country, date, new_cases_per_million))

d1_21_f$country <- factor (d1_21_f$country, levels = keep_countries)

```

## 7) Descriptive statistics & visualisations
 We summarise categories (counts/proportions), report center & spread for one mumeric variable and add simple plots to visualise patterns 
### 7.1) One-Way frequency table (categorical)
 Counts and proportions for a categorical variable 
```{r onewaytable}
# Counts and proportions for country
tab_country <- table(d1_21_f$country)
prop_country <- prop.table(tab_country)

tab_country
round(prop_country, 3)
```
  


### 7.2) Bar Chart of Disease.Category (counts)
 Bar chart / Bar plot of disease category by count 
```{r barplot}
# Bar chart / Bar plot of disease category by count
med_cases <- tapply(d1_21_f$new_cases_per_million,
                    d1_21_f$country,
                    median, na.rm = TRUE)

barplot(med_cases,
        main = "Median daily new cases per million (2021)", 
        xlab = "Country",
        ylab = "Median new cases per million",
        las = 2)

```
  


### 7.3) Two way table (category by category)
  
```{r twowaytable}
# Cross-tab and row/column proportions
threshold <- 50

d_tw <- subset(d1_21_f, !is.na(new_cases_per_million))

d_tw$high_day <- d_tw$new_cases_per_million > threshold

tw <- table(d_tw$country, d_tw$high_day)
tw

round(prop.table(tw, margin = 1), 3)
round(prop.table(tw, margin = 2), 3)

addmargins(tw)
row_high <- round(prop.table(tw, margin = 1)[, "TRUE"], 3)
row_high

```
  


### 7.4) Center & Spread (overall, selected countries, 2021)
  
```{r center_and_spread}



x <- d1_21_f$new_cases_per_million
x <- x[!is.na(x)]

overall_stats <- c(
  mean = mean(x),
  median = median(x),
  min = min(x),
  max = max(x),
  range = diff(range(x)),
  IQR = IQR(x),
  sd = sd(x))

round(overall_stats[c("median","IQR","sd")], 1)


#By Countries summaries 
by_med <- tapply(d1_21_f$new_cases_per_million, d1_21_f$country, median, na.rm = TRUE)
by_iqr <- tapply(d1_21_f$new_cases_per_million, d1_21_f$country, IQR, na.rm = TRUE)
by_sd <- tapply(d1_21_f$new_cases_per_million, d1_21_f$country, sd, na.rm = TRUE)


by_summ <- data.frame(
    country = names(by_med),
    median = round(by_med, 1),
    IQR = round(by_iqr, 1),
    sd = round(by_sd, 1),
    row.names = NULL
)

print(by_summ)

```
  


### 7.5) Histogram (shape of the distrubution)
  
```{r histogram}

#Dropping NA's
x <- d1_21_f$new_cases_per_million
x <- x[!is.na(x)]

# Looking at the shape of the distrubution through a histogram
h <- hist(x ,
          probability = TRUE, # Relative frequency histogram
          main = "Daily new cases per million",
          xlab = "New cases per million",
          ylab = "Relative Frequency",
          breaks = 50,
          xlim = c(0,1500),
          col = "purple",
          border = "black")

# Add frequency polygon (connects midpoints of histogram bins)
  lines(h$mids, h$density, type = "l", col = "red", lwd = 2)

# Adding a smooth density curve for comparison
  lines(density(x), col = "orange", lwd = 2, lty = 2)

# Add legend
legend("topright",
       legend = c("Density", "Density Curve"),
       col = c("red", "orange"),
       lwd = 2,
       lty = c(1, 2))

```
  


### 7.6) Boxplot (numeric by category)
 Boxplot (Mortality rate by category) 
```{r boxplot}
# Boxplot

  # Order by median
  d1_21_f$country <- reorder(d1_21_f$country, d1_21_f$new_cases_per_million, median, na.rm = TRUE)

  # % of high days per country
  ## Reusing previously set threshold of '50'
  
  d_tmp <- subset(d1_21_f, !is.na(new_cases_per_million))
  pct_high <- tapply(d_tmp$new_cases_per_million > threshold,
                     d_tmp$country, function(z) mean(z, na.rm = TRUE))
  pct_high <- round(100 * pct_high[levels(d1_21_f$country)], 0)

  
  lab <- paste0(levels(d1_21_f$country), "\n", pct_high, "% >", threshold)
  
  #Box plot
  bp <- boxplot(new_cases_per_million ~ country, data = d1_21_f,
          names = lab,
          main = "Daily new cases per million, by country in 2021",
          ylab = "New cases per Million",
          xlab = "Country",
          col = "lightgreen",
          las = 2, 
          outline = TRUE,
          border = "purple")
  
  #Percentiles
  q <- quantile(d1_21_f$new_cases_per_million, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)

  # Adding a horizontal line for the quarters
  abline(h = q, col = c("blue", "red", "orange"), lty = c(2, 3, 2))
  
```
  


### 7.7) Simple time trend (average by year)
  
```{r timetrend}

#month index
d1_21_f$month_num <- as.integer(format(d1_21_f$date, "%m"))

# Monthly means by country
m_means <- aggregate(new_cases_per_million ~ country + month_num,
                     data = d1_21_f, FUN = function(z) mean(z, na.rm = TRUE))


countries = c("United States", "United Kingdom", "China","Belgium")
mat <- with (m_means, tapply(new_cases_per_million, list(month_num, country), mean))
mat <- mat[1:12, countries, drop = FALSE]

# Set highest point to scale chart
y_max <- max(mat, na.rm = TRUE)

plot(1:12, mat[, "United States"], type = "l", lwd = 2,
     xaxt = "n", xlab = "Month in 2021",
     ylab = "mean new cases per million",
     main = "Monthly mean new cases per million",
     ylim = c(0, y_max * 1.1))

axis(1, at = 1:12, labels = month.abb)
lines(1:12, mat[, "United Kingdom"], lwd = 2)
lines(1:12, mat[, "China"], lwd = 2)
lines(1:12, mat[, "Belgium"], lwd = 2)

legend("topleft",
       legend = countries, 
       lwd = 2, bty = "n")

```
  
## 8) Planned statisical methods
We will compare 2021 distrubutions of 'new_cases_per_million' across the four countries using.... 

  
## 9) Limitations
- Measurement differences - countries have different reporting rules, testing cadence & breadth.
- Scope - Only 2021 was analysed. Other years or waves of the disease may show other patterns. 
- per million rates do not adjust for demographics of each country, which may show other patterns. 
- China has several near zero analysis - This may reflect reporting practices of this specific country


# Project Idea Two - Covid 19 Hospitalizations in France
# Link to the dataset

Kaggle - Coronavirusdataset France (file: `chiffres-cles.csv`)  
Actual URL: <https://www.kaggle.com/datasets/mclikmb4/coronavirusdataset-france?select=chiffres-cles.csv>
Google drive URL: <https://drive.google.com/file/d/1rXHdGEDWFAMaitmkNSgehAt_e2FaC_PZ/view?usp=sharing>

# Introduction to the dataset

This dataset provides daily COVID-19 surveillance indicators for France at multiple geographic granularities (country, region, department, overseas collectivities). Each record includes a calendar date, a location code, and a location name, enabling comparisons across space and time. Indicators cover hospitalized patients, ICU occupancy, cumulative deaths, cumulative recoveries, and daily flows of new admissions (hospital and ICU). Source/provenance fields support auditability. The structure suits descriptive analyses and visualizations, with optional regional comparisons to highlight spatial heterogeneity. These indicators and their definitions are documented on the Kaggle dataset page (mclikmb4, 2020-2021).

# Dataset justification

**Relevance:** Directly biomedical/public-health, reflecting real-world hospital and ICU loads during COVID-19.

**Size/structure:** The file far exceeds the minimum requirements (well over 100 rows and more than 20 columns) and includes both categorical (granularity, location IDs, sources) and continuous (counts) variables.

**Accessibility/ethics:** Publicly accessible aggregated, de-identified counts suitable for academic use.

**Analytical potential:** Enables trend estimation, wave identification, geographic comparison, and lead-lag analysis between admissions (“flow”) and occupancy (“stock”).


**Ethical use.** The dataset consists of aggregated, de-identified counts without PII; no patient-level identifiers are present, aligning with course requirements for ethical, public data.


# Variables description

**Key columns:**  
`date` (daily), `granularity` (country, region, department), `location_code` (location code), `location_name` (location name).

**Indicators:**  
- `hospitalized` - current hospitalized patients  
- `icu_patients` - current ICU patients  
- `deaths` - cumulative deaths  
- `recovered` - cumulative recoveries  
- `new_hospitalizations` - new daily hospital admissions  
- `new_icu_admissions` - new daily ICU admissions  

**Additional fields:**  
`confirmed_cases` and `tested` may be present with different levels of completeness.  
**Note:** Due to several missing/invalid values (NaN/Inf), the `tested` column is largely unusable for analysis and is excluded from primary summaries and plots.

**Source metadata:**  
`source_name`, `source_url`, `source_archive`, `source_type`.

```{r results='hide'}
df <- readr::read_csv("https://drive.google.com/uc?export=download&id=1rXHdGEDWFAMaitmkNSgehAt_e2FaC_PZ", show_col_types = FALSE)

df <- df |>
  dplyr::mutate(
    granularity = dplyr::recode(granularity,
      "pays" = "country",
      "departement" = "department",
      "collectivite-outremer" = "overseas_collectivity",
      "monde" = "world",
      "region" = "region"
    )
  )


# Coerce likely numeric metrics
num_cols <- intersect(
  c("hospitalized","icu_patients","deaths","recovered",
    "new_hospitalizations","new_icu_admissions",
    "confirmed_cases","tested"),
  names(df)
)
df <- df |>
  mutate(
    date = as.Date(date),
    across(all_of(num_cols), ~suppressWarnings(as.numeric(.)))
  )

# Overview table for structure (TABLE ONLY)
gran_counts <- df |>
  count(granularity, name = "n") |>
  arrange(desc(n))

# Flattened numeric summary table (no list-columns)
summary_table <- df |>
  summarize(across(
    all_of(num_cols),
    list(
      n = ~sum(!is.na(.x)),
      mean = ~mean(.x, na.rm = TRUE),
      sd = ~sd(.x, na.rm = TRUE),
      median = ~median(.x, na.rm = TRUE),
      min = ~min(.x, na.rm = TRUE),
      max = ~max(.x, na.rm = TRUE)
    ),
    .names = "{.col}_{.fn}"
  )) |>
  pivot_longer(
    everything(),
    names_to = c("variable","stat"),
    names_sep = "_(?=[^_]+$)",
    values_to = "value"
  ) |>
  pivot_wider(names_from = "stat", values_from = "value") |>
  arrange(variable)
```

```{r}
kable(gran_counts, caption = "Row counts by geographic granularity")
kable(summary_table, digits = 3, caption = "Summary statistics for key numeric indicators")
```

# Research question(s)

1. **National waves:** How did France’s national hospitalization and ICU occupancy evolve across early pandemic waves (2020-2021)?  
2. **Flow-stock timing:** Do peaks in new hospital admissions precede peaks in current hospitalizations, and by roughly how many days?

# Data cleanup and processing plan

- **Parsing and types:** Ensure the `date` field is properly parsed as a date variable and convert indicator fields into numeric types for consistency.

- **Subsetting:** For national trends, include only rows classified as country with `location_code` = "FRA". For geographic comparisons, restrict the dataset to rows where `granularity` is region.

- **Missingness:** Quantify missing values for each column and handle them transparently by applying listwise deletion for plotted series (no imputation).

- **Duplicates:** Identify and remove duplicate entries defined by the combination of `date` and `location_code`.

- **Provenance:** Retain all source metadata fields, and include them in the appendix when relevant for transparency.

# Descriptive statistics (figures in Appendix)

France’s national indicators exhibit multi-wave patterns during 2020-2021. Hospital occupancy and ICU burden rise and fall in tandem with case surges, while cumulative deaths increase monotonically. The timing relationship between new admissions (flow) and current occupancy (stock) suggests admissions lead occupancy by several days. For visuals supporting these statements, see Appendix Figures A1-A3. Tables above summarize structure and central tendencies.

Across all rows, the median current hospitalizations was `r round(median(df$hospitalized, na.rm = TRUE))`, with an IQR of `r paste(round(quantile(df$hospitalized, probs = c(.25,.75), na.rm = TRUE)), collapse = "-")`; ICU occupancy had a much lower median, which is expected since ICU is a subset of the total hospital (median `r round(median(df$icu_patients, na.rm = TRUE))`), consistent with ICU being a subset of total hospital burden.

# Planned statistical methods

- **Lagged cross-correlation** between `new_hospitalizations` (flow) and `hospitalized` (stock) to estimate lead time from admissions to occupancy.  
- **Regional comparison** of ICU vs hospital burden by wave period (medians, IQRs).  
- **Simple time-series decomposition** on national hospitalizations to separate trend/seasonal/residual components (if applicable).


# Limitations

Several fields like `tested` and early `confirmed_cases` have bad coverage over time, and indicators are hospital-centric rather than community-representative. Counts are aggregated and de-identified, so patient-level cannot be controlled. Because the dataset mixes granularities (national, regional, departmental), comparing across levels requires careful subsetting (`granularity == "country"` for national trends). These constraints limit causal interpretation, so we have to focus more on descriptive trends and clearly labeled comparisons.

# Appendix

```{r results='hide'}
national <- df |>
  filter(granularity == "country", location_code == "FRA") |>
  arrange(date)

plot_series <- function(data, y, title_txt, ylab_txt = "Count") {
  ggplot(data, aes(x = date, y = .data[[y]])) +
    geom_line(color = "blue", linewidth = 0.8) +
    scale_x_date(date_breaks = "2 months",
                 date_labels = "%Y-%m",
                 expand = expansion(mult = c(0.01, 0.01))) +
    labs(x = "Date", y = ylab_txt, title = title_txt) +
    theme_minimal(base_size = 10) +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.title.y = element_text(margin = margin(r = 6))
    )
}

```

```{r echo=FALSE, fig.cap="France (national): Hospitalized (current) over time."}
if (all(c("hospitalized") %in% names(national))) {
  plot_series(national, "hospitalized", "France (national): Hospitalized (current) over time", ylab_txt = "Patients")
}
```

```{r echo=FALSE, fig.cap="France (national): ICU (current) over time."}
if (all(c("icu_patients") %in% names(national))) {
  plot_series(national, "icu_patients", "France (national): ICU (current) over time", ylab_txt = "Patients in ICU")
}
```

```{r echo=FALSE, fig.cap="France (national): Cumulative deaths over time."}
if (all(c("deaths") %in% names(national))) {
  plot_series(national, "deaths", "France (national): Cumulative deaths over time", ylab_txt = "Deaths (cumulative)")
}
```

\FloatBarrier
\newpage


# Project Idea Three - Heart attack

# DIVYA HERE !!!!!!!











# ) JOINT PROJECTS - References
Project 1 - Our World in Data. "Coronvirus Pandemic (COVID-19) dataset." source location - Source: URL: https://docs.owid.io/projects/covid/en/latest/dataset.html 
Project 2 - mclikmb4, (2021, April 4), Coronavirus-dataset France, Kaggle, <https://www.kaggle.com/datasets/mclikmb4/coronavirusdataset-france?select=chiffres-cles.csv> 

# ) PROJECTS - Appendix
## Project 1

## Project 2

```{r results='hide'}
national <- df |>
  filter(granularity == "country", location_code == "FRA") |>
  arrange(date)

plot_series <- function(data, y, title_txt, ylab_txt = "Count") {
  ggplot(data, aes(x = date, y = .data[[y]])) +
    geom_line(color = "blue", linewidth = 0.8) +
    scale_x_date(date_breaks = "2 months",
                 date_labels = "%Y-%m",
                 expand = expansion(mult = c(0.01, 0.01))) +
    labs(x = "Date", y = ylab_txt, title = title_txt) +
    theme_minimal(base_size = 10) +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.title.y = element_text(margin = margin(r = 6))
    )
}

```

```{r echo=FALSE, fig.cap="France (national): Hospitalized (current) over time."}
if (all(c("hospitalized") %in% names(national))) {
  plot_series(national, "hospitalized", "France (national): Hospitalized (current) over time", ylab_txt = "Patients")
}
```

```{r echo=FALSE, fig.cap="France (national): ICU (current) over time."}
if (all(c("icu_patients") %in% names(national))) {
  plot_series(national, "icu_patients", "France (national): ICU (current) over time", ylab_txt = "Patients in ICU")
}
```

```{r echo=FALSE, fig.cap="France (national): Cumulative deaths over time."}
if (all(c("deaths") %in% names(national))) {
  plot_series(national, "deaths", "France (national): Cumulative deaths over time", ylab_txt = "Deaths (cumulative)")
}
```



